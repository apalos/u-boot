// SPDX-License-Identifier: GPL-2.0+
/*
 * Copyright (c) 2020, Linaro Limited
 */

#include <common.h>
#include <dm.h>
#include <log.h>
#include <virtio_types.h>
#include <virtio.h>
#include <virtio_ring.h>
#include <mmc.h>

#define BUFFER_SIZE	16UL
#define _D printf("%s %d\n", __func__, __LINE__);
const unsigned char ext_csd[] = {
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xb3, 0x01, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x01, 0xb3, 0x01, 0x00,
	0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x05, 0x1f,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x05, 0x00, 0x02, 0x00, 0x07, 0x00, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0xc0, 0x6c, 0x00,
	0x00, 0x13, 0x00, 0x07, 0x07, 0x10, 0x01, 0x01,
	0x01, 0x07, 0x04, 0x00, 0x07, 0x0a, 0x0a, 0x15,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

struct s_rpmb {
	unsigned char stuff[196];
	unsigned char mac[32];
	unsigned char data[256];
	unsigned char nonce[16];
	unsigned int write_counter;
	unsigned short address;
	unsigned short block_count;
	unsigned short result;
	unsigned short request;
};

struct virtio_mmc_plat {
	struct mmc_config cfg;
	struct mmc mmc;
};

struct virtio_rpmb_priv {
	struct virtqueue *rpmb_vq;
};

static int virtio_rpmb_send_cmd(struct udevice *dev, struct mmc_cmd *cmd,
				struct mmc_data *data)
{
	int ret;
	struct virtio_sg req, resp;
	struct virtio_sg *sgs[] = { &req, &resp };
	struct virtio_rpmb_priv *priv = dev_get_priv(dev);
	int in_sg = 0, out_sg = 0;
	unsigned char buf[MMC_MAX_BLOCK_LEN] __aligned(4);
	unsigned int rsize;
	struct s_rpmb *rpmb_frame;

	switch (cmd->cmdidx) {
	case MMC_CMD_ALL_SEND_CID:
		memset(cmd->response, '\0', sizeof(cmd->response));
		break;
	case SD_CMD_SEND_RELATIVE_ADDR:
		cmd->response[0] = 0 << 16; /* mmc->rca */
	case MMC_CMD_GO_IDLE_STATE:
		break;
	case MMC_CMD_SEND_STATUS:
		cmd->response[0] = MMC_STATUS_RDY_FOR_DATA;
		break;
	case MMC_CMD_SELECT_CARD:
		break;
	case MMC_CMD_SEND_CSD:
		cmd->response[0] = 4 << 26;
		cmd->response[1] = 10 << 16;	/* 1 << block_len */
		cmd->response[2] = 0;
		cmd->response[3] = 0;
		break;
	case SD_CMD_SWITCH_FUNC: {
		if (!data)
			break;
		u32 *resp = (u32 *)data->dest;
		resp[3] = 0;
		resp[7] = cpu_to_be32(SD_HIGHSPEED_BUSY);
		if ((cmd->cmdarg & 0xF) == UHS_SDR12_BUS_SPEED)
			resp[4] = (cmd->cmdarg & 0xF) << 24;
		break;
	}
	case MMC_CMD_STOP_TRANSMISSION:
		break;
	case SD_CMD_APP_SEND_OP_COND:
		cmd->response[0] = OCR_BUSY | OCR_HCS;
		cmd->response[1] = 0;
		cmd->response[2] = 0;
		break;
	case MMC_CMD_APP_CMD:
		/* force an eMMC scan */
		return -ETIMEDOUT;
	case MMC_CMD_SEND_EXT_CSD:
		if (data && data->flags == MMC_DATA_READ)
			memcpy(data->dest, ext_csd, 512);
		break;
	case MMC_CMD_SEND_OP_COND:
		cmd->response[0] = OCR_BUSY;
		break;
	case MMC_CMD_SET_BLOCK_COUNT:
		if ((cmd->cmdarg & 0x0000FFFF) != 1) {
			pr_err("blockcount must be 1\n");
			return -1;
		}

		break;
	case MMC_CMD_READ_SINGLE_BLOCK:
	case MMC_CMD_READ_MULTIPLE_BLOCK:
	case MMC_CMD_WRITE_MULTIPLE_BLOCK:
		if (!data)
			break;
		if (data->flags == MMC_DATA_READ)
			rpmb_frame = (struct s_rpmb *) data->dest;
		else
			rpmb_frame = (struct s_rpmb *) data->src;

		if (rpmb_frame->request != cpu_to_be16(1) &&
		    rpmb_frame->request !=  cpu_to_be16(2) &&  //RPMB_REQ_WCOUNTER
		    rpmb_frame->request !=  cpu_to_be16(5)) { //RPMB_REQ_STATUS
			printf("Unhandled request %d\n", cpu_to_be16(rpmb_frame->request));
			break;
		}
		req.length = data->blocks * data->blocksize;
		resp.length = data->blocks * data->blocksize;

		//FIXME contructs the buffers correctly and read
		//cmd->resp_type to fo it
		if (data->flags == MMC_DATA_READ) {
			req.addr = data->dest;
			resp.addr = (void *)data->src;
			in_sg++;
			out_sg++;
		} else if (data->flags == MMC_DATA_WRITE) {
			/*
			 * virio-rpmb spec doesn't send a reply .
			 * it will send when VIRTIO_RPMB_REQ_RESULT_READ is
			 * requested*/
			if (rpmb_frame->request == cpu_to_be16(1))
				out_sg++;
			else {
				in_sg++;
				out_sg++;
			}
			req.addr = (void *)data->src;
			resp.addr = buf;
		}
		ret = virtqueue_add(priv->rpmb_vq, sgs, out_sg, in_sg);
		if (ret) {
			pr_err("Failed to add virtqueues\n");
			return ret;
		}
		virtqueue_kick(priv->rpmb_vq);
		if (cmd->resp_type != MMC_RSP_NONE && rpmb_frame->request != cpu_to_be16(1)) {
			while (!virtqueue_get_buf(priv->rpmb_vq, &rsize))
				;
		 }
		break;
	case MMC_CMD_SET_BLOCKLEN:
		printf("block len %d\n", cmd->cmdarg);
		break;
	case SD_CMD_APP_SEND_SCR: {
		u32 *scr = (u32 *)data->dest;

		scr[0] = cpu_to_be32(2 << 24 | 1 << 15);  /* SD version 3 */
		break;
	}
	default:
		printf("%s: Unknown command %d\n", __func__, cmd->cmdidx);
		break;
	}

	return 0;
}

static int virtio_rpmb_bind(struct udevice *dev)
{
	struct virtio_dev_priv *uc_priv = dev_get_uclass_priv(dev->parent);
	struct virtio_mmc_plat *plat = dev_get_platdata(dev);
	struct mmc_config *cfg = &plat->cfg;

	cfg->name = dev->name;
	cfg->host_caps = MMC_MODE_HS_52MHz | MMC_MODE_HS | MMC_MODE_8BIT;
	cfg->voltages = MMC_VDD_165_195 | MMC_VDD_32_33 | MMC_VDD_33_34;
	cfg->f_min = 1000000;
	cfg->f_max = 52000000;
	cfg->b_max = U32_MAX;

	/* Indicate what driver features we support */
	virtio_driver_features_init(uc_priv, NULL, 0, NULL, 0);

	return mmc_bind(dev, &plat->mmc, cfg);
}

static int virtio_rpmb_probe(struct udevice *dev)
{
	struct virtio_rpmb_priv *priv = dev_get_priv(dev);
	struct virtio_mmc_plat *plat = dev_get_platdata(dev);
	int ret;

	ret = virtio_find_vqs(dev, 1, &priv->rpmb_vq);
	if (ret < 0) {
		pr_err("Failed to find virtqueues\n");
		return ret;
	}

	return mmc_init(&plat->mmc);
}

static int virtio_mmc_set_ios(struct udevice *dev)
{
	return 0;
}

static int virtio_mmc_get_cd(struct udevice *dev)
{
	return 1;
}

static struct dm_mmc_ops virtio_rpmb_ops = {
	.send_cmd = virtio_rpmb_send_cmd,
	.set_ios = virtio_mmc_set_ios,
	.get_cd = virtio_mmc_get_cd,
};

U_BOOT_DRIVER(virtio_rpmb) = {
	.name	= VIRTIO_RPMB_DRV_NAME,
	.id	= UCLASS_MMC,
	.bind	= virtio_rpmb_bind,
	.probe	= virtio_rpmb_probe,
	.remove = virtio_reset,
	.ops	= &virtio_rpmb_ops,
	.priv_auto_alloc_size = sizeof(struct virtio_rpmb_priv),
	.platdata_auto_alloc_size = sizeof(struct virtio_mmc_plat),
	.flags	= DM_FLAG_ACTIVE_DMA, //FIXME ??
};
